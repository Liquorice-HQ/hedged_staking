/// Helper functions for strategy
///

use async_recursion::async_recursion;
use log::{ info, debug, trace, warn };
use rand::Rng;
use rand_distr::{Distribution, Normal};
use regex::Regex;
use rust_decimal::*;
use rust_decimal::Decimal;
use rust_decimal::prelude::ToPrimitive;
use rust_decimal_macros::dec;
use std::cmp::max;
use std::convert::From;
use std::ffi::OsStr;
use std::process::Command;
use tokio::{ try_join, time::{ sleep, Duration } };

use openlimits::dydx::{ decode_eth_address, decode_eth_key };
use openlimits::errors::*;
use openlimits::exchange::*;
use openlimits::model::*;

use crate::consts::*;
use crate::monitoring;
use crate::types::*;
use crate::utils::*;


/// Outputs random "client id".
///
pub fn get_random_client_order_id() -> String {
    let mut rng = rand::thread_rng();
    //let client_id_int = rng.gen::<u32>();
    let client_id_int = rng.gen_range(1..0x7FFFFFFF);
    // NOTE from https://docs.kraken.com/rest/#operation/addOrder :
    //
    // `userref` is an optional user-specified integer id that can be
    // associated with any number of orders. Many clients choose a
    // userref corresponding to a unique integer id generated by
    // their systems (e.g. a timestamp). However, because we don't
    // enforce uniqueness on our side, it can also be used to easily
    // group orders by pair, side, strategy, etc. This allows clients
    // to more readily cancel or query information about orders in a
    // particular group, with fewer API calls by using userref
    // instead of our txid, where supported.
    client_id_int.to_string()
}


// TODO transform to macros!
pub fn err(msg: String) -> core::result::Result<(), StrategyError> { // TODO add formatting caps.
    Err(StrategyError::Misc { msg })
}


#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RFE { // round for exchange
    Price,
    Amount,
}


/// Round up the `amount` to meet the requirements of the exchage `we`.
///
fn round_for_exchange(side: Side, we: WhichExchange, _from: &str, _to: &str, rfe: RFE, amount: Value) -> Value {
    let rs = match (side, rfe) {
        (Side::Buy, RFE::Price) => rust_decimal::RoundingStrategy::AwayFromZero,
        (Side::Buy, RFE::Amount) => rust_decimal::RoundingStrategy::ToZero,
        (Side::Sell, RFE::Price) => rust_decimal::RoundingStrategy::ToZero,
        (Side::Sell, RFE::Amount) => rust_decimal::RoundingStrategy::ToZero, //???
    };
    match we {
        WhichExchange::First => {
            let dp = match rfe {
                RFE::Price => 1,
                RFE::Amount => 1,
            };
            amount.round_dp_with_strategy(dp, rs)
        },
        WhichExchange::Second => {
            let dp = match rfe {
                RFE::Price => 4,
                RFE::Amount => 4,
            };
            let amnt = match rfe {
                RFE::Price => amount,
                RFE::Amount => amount * dec!(0.999), // sometimes Kraken for some reason throw
                                                     // "Insufficient funds" error, so we slightly
                                                     // decrease amount.
            };
            amnt.round_dp_with_strategy(dp, rs)
        }
        WhichExchange::Exchange => {
            // TODO check again or move to config file
            let dp = match rfe {
                RFE::Price => 3,
                RFE::Amount => 2,
            };
            amount.round_dp_with_strategy(dp, rs)
        }
        WhichExchange::Wallet => todo!(),
    }
}


pub async fn get_token_price(ctx: &mut Context, we: WhichExchange) -> StrategyResult<BuySellPrice> {
    let market_pair = get_market_pair_name(we, OPERATING_COIN, INTERMEDIATE_COIN);
    let ob = match we {
            WhichExchange::First => &ctx.connections.e1 as &dyn ExchangeMarketData,
            WhichExchange::Second => &ctx.connections.e2 as &dyn ExchangeMarketData,
            WhichExchange::Exchange => &ctx.connections.ee_trade as &dyn ExchangeMarketData,
            WhichExchange::Wallet => unreachable!(),
        }.order_book(&OrderBookRequest { market_pair: market_pair.to_string() }).await?;
    Ok(BuySellPrice {
        buy: ob.asks.first().expect("Some asks must be present").price,
        sell: ob.bids.first().expect("Some bids must be present").price
    })
}


/// Make `amount` of `to` tokens using `from` tokens in exchange `we` using `side` (buy or sell) operation.
///
/// Note that we using `limit_buy` / `limit_sell` method to avoid flash-crash scenario.
///
pub async fn change_tokens_ex(ctx: &mut Context, we: WhichExchange, side: Side, asset: Asset) -> ActionResult {
    let is_buying = side == Side::Buy; 
    let market_pair = get_market_pair_name(we, OPERATING_COIN, TRANSFERRING_COIN);
    let op_name = if is_buying { "Buying" } else { "Selling" };
    let we_name = get_exchange_name(we);
    debug!("{}: {} {} to {} (market pair: {})", we_name, op_name, asset, TRANSFERRING_COIN, market_pair) ;
    let (exch_md, exch_acc): (&dyn ExchangeMarketData, &dyn ExchangeAccount) = match we {
        WhichExchange::First => (&ctx.connections.e1, &ctx.connections.e1),
        WhichExchange::Second => (&ctx.connections.e2, &ctx.connections.e2),
        WhichExchange::Exchange => (&ctx.connections.ee_trade, &ctx.connections.ee_trade),
        WhichExchange::Wallet => unreachable!(),
    };
    loop {
        debug!("Try to get orderbook for market pair {}", market_pair);
        let ob = exch_md.order_book(&OrderBookRequest { market_pair: market_pair.to_string() }).await?;
        trace!("Order book asks: {:?}", ob.asks);
        trace!("Order book bids: {:?}", ob.bids);
        let price = if is_buying { ob.asks } else { ob.bids }.first().expect("Some asks/bids must be present").price;
        debug!("Current {} price: {}", market_pair, price);
        let limit_rounding_coeff = dec!(0.01); // we slightly increase/decrease limit price to buy in one order
        let (fixed_amount, fixed_price) : (SecondaryAsset, Price) =
            if is_buying {
                let limit_price = round_for_exchange(Side::Buy, we, TRANSFERRING_COIN, OPERATING_COIN, RFE::Price, price * (ONE + limit_rounding_coeff));
                let to_amount_raw = match asset {
                    Asset::Primary(amount) => amount.to_sec(limit_price),
                    Asset::Secondary(amount) => amount,
                };
                let to_amount = round_for_exchange(Side::Buy, we, TRANSFERRING_COIN, OPERATING_COIN, RFE::Amount, *to_amount_raw).into();
                (to_amount, limit_price)
            }
            else {
                let limit_price = round_for_exchange(Side::Sell, we, TRANSFERRING_COIN, OPERATING_COIN, RFE::Price, price * (ONE - limit_rounding_coeff));
                let to_amount_raw = match asset {
                    Asset::Primary(amount) => amount.to_sec(limit_price),
                    Asset::Secondary(amount) => amount,
                };
                let to_amount = round_for_exchange(Side::Sell, we, TRANSFERRING_COIN, OPERATING_COIN, RFE::Amount, *to_amount_raw).into();
                (to_amount, limit_price)
            };
        let req = OpenLimitOrderRequest
                { market_pair: market_pair.to_owned(),
                  size: *fixed_amount,
                  price: fixed_price,
                  time_in_force: TimeInForce::GoodTillCanceled,
                  post_only: false,
                  client_order_id: Some(get_random_client_order_id()),
                };
        debug!("{}: {} {} (price: {}, limit price: {}), request: {:?}", we_name, op_name, fixed_amount, price, fixed_price, req);
        match if is_buying { exch_acc.limit_buy(&req).await } else { exch_acc.limit_sell(&req).await } {
            Err(err) => {
                if is_error_insufficient_funds(&err) { // TODO
                    warn!("{}: buying {}: Can't execute order on price {}. Error: \"{}\". Retrying...",
                          we_name, fixed_amount, fixed_price, err.to_string());
                    sleep(Duration::from_secs(1)).await;
                }
                else {
                    return Err(StrategyError::from(err));
                }
            },
            Ok(ord) => {
                debug!("Order info: {:?}", ord);
                debug!("Order ID: {}", ord.id);
                loop {
                    let Order { status, .. } = exch_acc.get_order(&GetOrderRequest { id: ord.id.clone(), market_pair: Some(market_pair.to_owned()) }).await?;
                    if status == OrderStatus::Filled {
                        debug!("Order {} is filled", ord.id);
                        update_balances(ctx, Some(we)).await?;
                        break;
                    }
                    debug!("Waiting for filling order {}", ord.id);
                    sleep(Duration::from_secs(1)).await;
                }
                break;
            }
        }
    }
    Ok(())
}


fn get_value_by_regex(s: &str, re: &str) -> String {
    let pattern = Regex::new(re).unwrap();
    pattern.captures(s).unwrap()[1].to_owned()
}


fn get_amount_by_regex(s: &str, re: &str) -> i64 {
    get_value_by_regex(s, re).parse().unwrap()
}


pub async fn dydx_make_short_position(ctx: &mut Context, amount: SecondaryAsset) -> ActionResult {
    info!("{}: try to make short position (sell) {} for {}", E1_NAME, OPERATING_COIN, amount);
    change_tokens_ex(ctx, WhichExchange::First, Side::Sell, Asset::Secondary(amount)).await?;
    info!("{}: successful made short position {} for {}", E1_NAME, OPERATING_COIN, amount);
    Ok(())
}


pub async fn dydx_close_short_position(ctx: &mut Context, amount: SecondaryAsset) -> ActionResult {
    info!("{}: try to close part of short position (buy) {} for {}", E1_NAME, OPERATING_COIN, amount);
    change_tokens_ex(ctx, WhichExchange::First, Side::Buy, Asset::Secondary(amount)).await?;
    info!("{}: successful close part of short position {} for {}", E1_NAME, OPERATING_COIN, amount);
    Ok(())
}


async fn run_script<I, S>(args: I) -> StrategyResult<String>
where
    I: IntoIterator<Item = S>,
    S: AsRef<OsStr>,
{
    let mut cmd_ = Command::new("python3");
    let cmd = cmd_.arg("-m").arg("eth-operations").args(args);
    trace!("{}: cmd: {:?}", WALLET_NAME, cmd);
    let output = cmd.output()?;
    trace!("{}: cmd: {:?}, {}", WALLET_NAME, cmd, output.status);
    let stdout: String = String::from_utf8(output.stdout).unwrap().trim().to_owned();
    trace!("{}: STDOUT: \"{}\"", WALLET_NAME, stdout);
    let stderr: String = String::from_utf8(output.stderr).unwrap().trim().to_owned();
    trace!("{}: STDERR: \"{}\"", WALLET_NAME, stderr);
    if !output.status.success() {
        let msg = if stderr.is_empty() { format!("Bad exit status: {}, error message: {}", stderr, stderr) }
                  else { format!("Bad exit status: {}", stderr) };
        return Err(StrategyError::Misc { msg });
    }
    if ! stderr.is_empty() {
        //return err(format!("Error when call balance for {}: \"{}\"", WALLET_NAME, stderr))
        return Err(StrategyError::Misc { msg: format!("Error message: {}", stderr) }); 
    }
    Ok(stdout)
}


async fn get_e1_balances(e1: &FirstExchange) -> StrategyResult<E1Balances> {
    match e1.get_account_balances(None).await {
        Err(err) => Err(StrategyError::Misc { msg: err.to_string() }),
        Ok(bals) => {
            trace!("Balances on {}: {:?}", get_exchange_name(WhichExchange::First), bals);
            let mut bal : E1Balances = Default::default();
            for b in bals.iter() {
                if b.asset == "ATOM-USD" {
                    bal.operational_coins = b.total.into();
                }
                if b.asset == "USDC" {
                    bal.total = b.total.into();
                    bal.free = b.free.into();
                }
            }
            Ok(bal)
        }
    }
}


async fn get_e2_balances(e2: &SecondExchange) -> StrategyResult<E2Balances> {
    match e2.get_account_balances(None).await {
        Err(err) => Err(StrategyError::Misc { msg: err.to_string() }),
        Ok(bals) => {
            trace!("Balances on {}: {:?}", get_exchange_name(WhichExchange::Second), bals);
            let mut bal : E2Balances = Default::default();
            for b in bals.iter() {
                if b.asset == TRANSFERRING_COIN {
                    bal.transferring_coins = b.free.into();
                } else if b.asset == INTERMEDIATE_COIN {
                    bal.intermediate_coins = b.free.into();
                } else if b.asset == E2_STAKED_COIN {
                    bal.staked_coins = b.free.into();
                } else if b.asset == E2_UNSTAKED_COIN {
                    bal.unstaked_coins = b.free.into();
                }
            }
            Ok(bal)
        }
    }
}


async fn get_ee_balances(ee: & ExchangeExchange) -> StrategyResult<EEBalances> {
    match ee.get_account_balances(None).await {
        Err(err) => Err(StrategyError::Misc { msg: err.to_string() }),
        Ok(bals) => {
            //trace!("Balances on {}: {:?}", get_exchange_name(WhichExchange::Exchange), bals);
            let mut bal : EEBalances = Default::default();
            for b in bals.iter() {
                if b.asset == "BUSD" {
                    bal.transferring_coins = b.free.into();
                } else if b.asset == OPERATING_COIN {
                    bal.operational_coins = b.free.into();
                }
            }
            Ok(bal)
        }
    }
}


async fn get_wallet_balances() -> StrategyResult<WalletBalances> {
    trace!("{}: Getting balances via external script", WALLET_NAME);
    let raw_balances = run_script(["--balance"]).await?;
    Ok(WalletBalances {
        transferring_coins: Decimal::new(get_amount_by_regex(&raw_balances, r"USDC: ([0-9]+)"), 6).into(),
        gas_coins: Decimal::new(get_amount_by_regex(&raw_balances, r"ETH: ([0-9]+)"), 18)
    })
}


/// Load balances from one of exchanges
///
#[async_recursion]
pub async fn update_balances(ctx: &mut Context, we: Option<WhichExchange>) -> core::result::Result<Balances, StrategyError> {
    //
    // TODO caching
    // TODO additional functions for cache invalidation
    //
    if ctx.balances.is_none() {
        ctx.balances = Some(Default::default());
    }
    match we {
        None => {
            let (e1, e2, ee, w) =
                try_join!(
                    get_e1_balances(&ctx.connections.e1),
                    get_e2_balances(&ctx.connections.e2),
                    get_ee_balances(&ctx.connections.ee_funding),
                    get_wallet_balances())?;
            if let Some(ref mut b) = ctx.balances {
                b.e1 = e1;
                b.e2 = e2;
                b.ee = ee;
                b.wallet = w;
            }
            Ok(ctx.balances.unwrap())
        }
        Some(WhichExchange::First) => {
            let e1_bal = get_e1_balances(&ctx.connections.e1).await?;
            if let Some(ref mut b) = ctx.balances { b.e1 = e1_bal; }
            Ok(ctx.balances.unwrap())
        },
        Some(WhichExchange::Second) => {
            let e2_bal = get_e2_balances(&ctx.connections.e2).await?;
            if let Some(ref mut b) = ctx.balances { b.e2 = e2_bal; }
            Ok(ctx.balances.unwrap())
        },
        Some(WhichExchange::Exchange) => {
            let ee_bal = get_ee_balances(&ctx.connections.ee_trade).await?;
            if let Some(ref mut b) = ctx.balances { b.ee = ee_bal; }
            Ok(ctx.balances.unwrap())
        },
        Some(WhichExchange::Wallet) =>  {
            let wallet_bal = get_wallet_balances().await?;
            if let Some(ref mut b) = ctx.balances { b.wallet = wallet_bal; }
            Ok(ctx.balances.unwrap())
        }
    }
}


pub fn is_error_insufficient_funds(err: &OpenLimitsError) -> bool {
    match err {
        OpenLimitsError::KrakenError(KrakenContentError { messages }) =>
            messages.iter().any(|m| m.to_lowercase().contains("insufficient")), // TODO how to prop.checking?
        OpenLimitsError::DydxError(DydxContentError { errors }) =>
            // We suppose such errors as "insuff. funds" to repeat
            errors.iter().any(|m| m.msg.to_lowercase().contains("invalid signature")),
        OpenLimitsError::BinanceError(BinanceContentError { code, .. }) =>
            *code == -2010,
        _ =>
            false,
    }
}


/// Asks and outputs to log current balances on exchanges.
///
pub async fn log_balances(ctx: &mut Context) -> ActionResult {
    let balances = update_balances(ctx, None).await?;
    info!("{} balance: total: {}, free: {}, in operation: {}",
        E1_NAME,
        balances.e1.total,
        balances.e1.free,
        -balances.e1.operational_coins);
    info!("{} balance: {}, {}, unstaked: {}, staked: {}",
        E2_NAME,
        balances.e2.transferring_coins,
        balances.e2.intermediate_coins,
        balances.e2.unstaked_coins,
        balances.e2.staked_coins);
    info!("{} balance: {}, {}",
        EE_NAME,
        balances.ee.transferring_coins,
        balances.ee.operational_coins);
    info!("{} balance: {}, gas: {:.6} {}",
        WALLET_NAME,
        balances.wallet.transferring_coins,
        balances.wallet.gas_coins, GAS_COIN);
    Ok(())
}


pub async fn internal_do_deposit(ctx: &mut Context, we: WhichExchange, amount: PrimaryAsset) -> ActionResult  { 
    let we_name = get_exchange_name(we);
    let am : Value = *amount * dec!(1000000);
    let raw_amount = am.round_dp_with_strategy(0, RoundingStrategy::ToZero);
    let bal = update_balances(ctx, None).await?;
    let wallet_initial_prim_amount = bal.wallet.transferring_coins;
    let wallet_initial_gas_amount = bal.wallet.gas_coins;
    debug!("{}: Make deposit {} to {}", WALLET_NAME, amount, get_exchange_name(we));
    let number = match we { WhichExchange::First => "1", WhichExchange::Second => "2", WhichExchange::Exchange => "3", _ => unimplemented!() };
    let raw_answer = run_script(["--deposit", number, &raw_amount.to_string()]).await?;
    let txhash = get_value_by_regex(&raw_answer, r"TXHASH: (0x[0-9a-fA-F]+)");
    info!("{}: {} sent to {}, txhash: https://etherscan.io/tx/{}", WALLET_NAME, amount, get_exchange_name(we), txhash);
    let amount_after_comission = amount * dec!(0.9); // commisions etc...
    let initial_we_amount = get_free_transferring_coins(&bal, we);
    let expected_amount = amount_after_comission + initial_we_amount;
    loop {
        let current_free = get_free_transferring_coins(&update_balances(ctx, Some(we)).await?, we);
        if current_free >= expected_amount {
            break;
        }
        else {
            // TODO send message to Telegram from time to time with `info` level
            debug!("{}: waiting for topup to at least {} (now: {})", we_name, expected_amount, current_free);
            sleep(Duration::from_secs(3)).await;
        }
    }

    // Expenses calculation
    let bal = update_balances(ctx, None).await?;
    let wallet_prim_delta = wallet_initial_prim_amount - bal.wallet.transferring_coins;
    let gas_expense = wallet_initial_gas_amount - bal.wallet.gas_coins;
    let now_free = get_free_transferring_coins(&bal, we);
    let we_prim_delta = now_free - initial_we_amount;
    // On dYdX there may be a jump in price after topping up,
    // which may cause free to change (due to margin changes).
    // That is why we limit spending to "0".
    let expense = max(wallet_prim_delta - we_prim_delta, ZERO_P);
    info!("{}: topped up to {}, expense: {}, gas: {} ETH", we_name, now_free, expense, gas_expense);
    if gas_expense >= ZERO { 
        match we {
            WhichExchange::First => {
                monitoring::WALLET_TO_E1_GAS_EXPENSE.inc_by(gas_expense.to_f64().unwrap());
                monitoring::WALLET_TO_E1_PRIM_EXPENSE.inc_by(expense.to_f());
            },
            WhichExchange::Exchange => {
                monitoring::WALLET_TO_EE_GAS_EXPENSE.inc_by(gas_expense.to_f64().unwrap());
                monitoring::WALLET_TO_EE_PRIM_EXPENSE.inc_by(expense.to_f());
            },
            _ => unimplemented!(),
        }
    }
    Ok(())
}


pub async fn internal_do_e1_deposit(ctx: &mut Context, amount: PrimaryAsset) -> ActionResult { 
    internal_do_deposit(ctx, WhichExchange::First, amount).await
}


pub async fn internal_do_ee_to_e2_deposit_operating(ctx: &mut Context, amount: SecondaryAsset) -> ActionResult {
    // TODO DRY: unite code with `internal_do_withdraw`
    let init_ee_coins = update_balances(ctx, Some(WhichExchange::Exchange)).await?.ee.operational_coins;
    let wreq = WithdrawRequest {
        asset: OPERATING_COIN.to_string(),
        amount: *amount,
        details: WithdrawalRequestDetails::Binance {
            client_id: Some(get_random_client_order_id()),
            network: None,
            address: ctx.e2_operational_token_deposit_address.to_owned(),
            address_tag: None,
            transaction_fee_flag: None,
            name: None,
            wallet_type: None,
            }};
    debug!("{}: withdraw request to {}: {:?}", EE_NAME, E2_NAME, &wreq);
    let wres = ctx.connections.ee_funding.withdraw(&wreq).await?;
    debug!("{}: withdraw response: {:?}", EE_NAME, &wres);
    let mut bal = update_balances(ctx, Some(WhichExchange::Second)).await?;
    let init_e2_coins = bal.e2.unstaked_coins;
    let commission = dec!(0.01);
    let expected_coins = init_e2_coins + (amount - commission.into()) * dec!(0.9); // commissions, etc.
    loop {
        sleep(Duration::from_secs(5)).await;
        bal = update_balances(ctx, Some(WhichExchange::Second)).await?;
        if bal.e2.unstaked_coins > expected_coins {
            break;
        };
        debug!("{}: waiting for transfer from {}, current balances: {}", E2_NAME, EE_NAME, bal.e2.unstaked_coins);
    };
    let final_e2_coins = bal.e2.unstaked_coins;
    let delta_e2 = final_e2_coins - init_e2_coins;
    let final_ee_coins = update_balances(ctx, Some(WhichExchange::Exchange)).await?.ee.operational_coins;
    let delta_ee = init_ee_coins - final_ee_coins;
    let expense = delta_ee - delta_e2;
    info!("{}: {} withdrawn, {}: {}, expense: {}",
          EE_NAME, amount,
          E2_NAME, bal.e2.unstaked_coins,
          expense);
    if expense < ZERO_S {
        warn!("{}: withdrawn: negative expense: {}", EE_NAME, expense);
    }
    else {
        monitoring::EE_TO_E2_SEC_EXPENSE.inc_by(expense.to_f());
    }
    Ok(())
}


pub async fn internal_do_e2_to_ee_deposit_operating(ctx: &mut Context, amount: SecondaryAsset) -> ActionResult {
    // TODO DRY: unite code with `internal_do_withdraw`
    let bal = update_balances(ctx, Some(WhichExchange::Second)).await?;
    let init_e2_coins = bal.e2.unstaked_coins;
    let wreq = WithdrawRequest {
        asset: OPERATING_COIN.to_string(),
        amount: amount.round(6).into(),
        details: WithdrawalRequestDetails::Kraken { key: ctx.e2_withdrawal_key_operational.to_owned() } };
    debug!("{}: {} withdraw request to {}: {:?}", E2_NAME, OPERATING_COIN, EE_NAME, &wreq);
    let wres = ctx.connections.e2.withdraw(&wreq).await?;
    debug!("{}: withdraw response: {:?}", E2_NAME, &wres);
    let mut bal = update_balances(ctx, Some(WhichExchange::Exchange)).await?;
    let init_ee_coins = bal.ee.operational_coins;
    let commission = SecondaryAsset(dec!(0.1));
    let expected_coins = init_ee_coins + (amount - commission) * dec!(0.9); // commissions, etc.
    loop {
        sleep(Duration::from_secs(5)).await;
        bal = update_balances(ctx, Some(WhichExchange::Exchange)).await?;
        if bal.ee.operational_coins > expected_coins {
            break;
        };
        debug!("{}: waiting for withdraw {} from {}, current balances: {}", EE_NAME, amount, E2_NAME, bal.ee.operational_coins);
    };
    let delta_ee_coins = bal.ee.operational_coins - init_ee_coins;
    let final_e2_coins = update_balances(ctx, Some(WhichExchange::Second)).await?.e2.unstaked_coins;
    let delta_e2_coins = init_e2_coins - final_e2_coins;
    let expense = delta_e2_coins - delta_ee_coins;
    info!("{}: {} withdrawn, {}: {}, expense: {}", E2_NAME, amount, EE_NAME, bal.ee.operational_coins, expense);
    if expense < ZERO_S {
        warn!("{}: withdrawn: negative expense: {}", EE_NAME, expense);
    }
    else {
        monitoring::E2_TO_EE_SEC_EXPENSE.inc_by(expense.to_f());
    }
    Ok(())
}


async fn make_withdraw_request(ctx: &mut Context, amount: PrimaryAsset, we: WhichExchange) -> StrategyResult<WithdrawRequest> {
    match we {
        WhichExchange::First => {
            let amount_rounded = Value::from(amount).round_dp_with_strategy(2, RoundingStrategy::ToZero);
            let info = ctx.connections.e1.get_fast_withdrawal_info(Some(amount_rounded), None).await.unwrap();
            debug!("{}: fast withdrawal info: {:?}", E1_NAME, info);
            let lp = info.liquidity_providers.values().next().unwrap();
            let deb_amount: Value = lp.quote.as_ref().unwrap().debit_amount.parse().unwrap();
            debug!("{}: expected debit amount: {:?}", E1_NAME, deb_amount); let to_address = decode_eth_address(ctx.e1_eth_withdraw_address.strip_prefix("0x").unwrap_or(&ctx.e1_eth_withdraw_address)).unwrap();
            Ok(WithdrawRequest {
                asset: TRANSFERRING_COIN.to_string(),
                amount: amount_rounded,
                details: WithdrawalRequestDetails::Dydx {
                    client_id: get_random_client_order_id(),
                    to_address,
                    debit_amount: deb_amount,
                    expiration: None,
                    liquidity_provider_position_id: 2,
                    liquidity_provider_stark_public_key: decode_eth_key(&lp.stark_key).unwrap(),
                    },
            })
        },
        WhichExchange::Second => {
            Ok(WithdrawRequest {
                asset: E2_TRANSFERRING_COIN.to_string(),
                amount: amount.into(),
                details: WithdrawalRequestDetails::Kraken { key: ctx.e2_withdrawal_key.clone() } })
        },
        WhichExchange::Exchange => {
            // NOTE: this is only for withdraw USDC!
            Ok(WithdrawRequest {
                asset:  TRANSFERRING_COIN.to_owned(),
                amount: Value::from(amount).round_dp_with_strategy(0, RoundingStrategy::ToZero),
                details: WithdrawalRequestDetails::Binance {
                    client_id: Some(get_random_client_order_id()),
                    network: Some("ETH".to_string()),
                    address: ctx.wallet_withdraw_address.to_owned(),
                    address_tag: None,
                    transaction_fee_flag: None,
                    name: None,
                    wallet_type: None,
                } })
        },
        WhichExchange::Wallet => unreachable!(),
    }
}


pub async fn internal_do_withdraw(ctx: &mut Context, amount: PrimaryAsset, we: WhichExchange) -> ActionResult {
    let withdrawal_min : PrimaryAsset = 10.into(); // TODO
    let bal = update_balances(ctx, Some(we)).await?;
    let free_coins = get_free_transferring_coins(&bal, we);
    let we_name = get_exchange_name(we);
    if free_coins < amount {
        return Err(StrategyError::Misc { msg:
            format!("{}: only {} available, not enough to withdraw {}",
                    we_name, free_coins, amount)});
    }
    if amount < withdrawal_min {
        warn!("{}: {} too low (less then {}) for withdraw!",
              we_name, amount, withdrawal_min);
        return Ok(()); // TODO
    }
    let wreq = make_withdraw_request(ctx, amount, we).await?;
    let mut bal = update_balances(ctx, Some(WhichExchange::Wallet)).await?;
    let init_coins = bal.wallet.transferring_coins;
    let commission = (if we == WhichExchange::Second { E2_WITHDRAW_COMMISSION } else { ZERO }).into();
    let expected_coins = init_coins + (amount - commission) * dec!(0.9); // commissions, etc.
    debug!("{}: trying to withdraw: request: {:?}, current balances: {:?}", we_name, wreq, bal);
    let wreqid = match we {
        WhichExchange::First => ctx.connections.e1.withdraw(&wreq).await?,
        WhichExchange::Second => ctx.connections.e2.withdraw(&wreq).await?,
        WhichExchange::Exchange => ctx.connections.ee_funding.withdraw(&wreq).await?,
        _ => unreachable!(),
    };
    debug!("{}: withdraw {:?} refid: {}", we_name, wreq, wreqid.refid);
    loop {
        sleep(Duration::from_secs(5)).await;
        bal = update_balances(ctx, Some(WhichExchange::Wallet)).await?;
        if bal.wallet.transferring_coins > expected_coins {

            break;
        };
        debug!("{}: waiting for withdraw from {}, current balances: {}",
               WALLET_NAME, we_name, bal.wallet.transferring_coins);
    }
    let wallet_amount = bal.wallet.transferring_coins;
    let wallet_delta = wallet_amount - init_coins;
    let bal = update_balances(ctx, Some(we)).await?;
    let we_amount = get_free_transferring_coins(&bal, we);
    let we_delta = free_coins - we_amount;
    let expense = we_delta - wallet_delta;
    info!("{}: {} withdrawn, wallet: {}, expense: {}",
          we_name, amount, bal.wallet.transferring_coins, expense);
    if expense >= ZERO_P {
        match we {
            WhichExchange::First => monitoring::E1_TO_WALLET_PRIM_EXPENSE.inc_by(expense.to_f()),
            WhichExchange::Exchange => monitoring::EE_TO_WALLET_PRIM_EXPENSE.inc_by(expense.to_f()),
            _ => unimplemented!(),
        }
    }
    else {
        warn!("{}: negative transfer expense! {}", we_name, expense);
    }

    Ok(())
}


pub async fn stake_unstake_impl(ctx: &mut Context, is_stake: bool, amount: Option<SecondaryAsset>) -> ActionResult {
    let bal = update_balances(ctx, Some(WhichExchange::Second)).await?;
    let su_amount =
        amount
        .unwrap_or(if is_stake { bal.e2.unstaked_coins } else { bal.e2.staked_coins })
        .round(6)
        .max(ONE_S); // minimal operating value is 1 ATOM
    let prev_opposite_amount = if is_stake { bal.e2.staked_coins } else { bal.e2.unstaked_coins }; // TODO
    let op_prefix = if is_stake { "" } else { "un" };
    if su_amount < ctx.staking_min_limit { return err(format!("Too low {} tokens: {}!", E2_STAKED_COIN, su_amount)); }
    info!("{}: trying to {}stake {}...", E2_NAME, op_prefix, su_amount);
    let order_id = if is_stake {
        debug!("{}: trying to stake {:?}...", E2_NAME, su_amount);
        ctx.connections.e2.stake_assets(
            &StakeAssetRequest {
                method: "cosmos-staked".to_string(), // TODO select depends on E2_UNSTAKED_COIN
                asset: E2_UNSTAKED_COIN.to_string(),
                amount: (*su_amount).to_string() }).await?;
        "unknown".to_string() // TODO `stake_assets` must return ref_id to output to log
    }
    else {
        ctx.connections.e2.unstake_assets(
            &UnstakeAssetRequest {
                asset: E2_STAKED_COIN.to_string(),
                amount: (*su_amount).to_string() }).await?;
        "unknown".to_string()
    };
    loop { // TODO waiting on special transactions, not balances
        trace!("Waiting for finish {}staking order '{}'", op_prefix, order_id);
        sleep(Duration::from_secs(3)).await;
        let bal = update_balances(ctx, Some(WhichExchange::Second)).await?;
        let now_su_amount = if is_stake { bal.e2.staked_coins } else { bal.e2.unstaked_coins };
        if now_su_amount > prev_opposite_amount {
            break;
        }
    };
    info!("{}: {} {} {}staked", E2_NAME, su_amount, E2_UNSTAKED_COIN, op_prefix);
    Ok(())
}


/// Generates random order size (according to config).
///
fn rnd_order_size(ctx: &Context, to_change: PrimaryAsset) -> PrimaryAsset {
    // TODO how to use rand::Normal with Decimal??
    let max_order_usdc: f64 = ctx.consts.max_order_usdc.to_f64().unwrap();
    let max_order_std_dev_usdc: f64 = ctx.consts.max_order_std_dev_usdc.to_f64().unwrap();
    let rnd_dist = Normal::new(max_order_usdc, max_order_std_dev_usdc).unwrap();
    let order_size = PrimaryAsset(Decimal::from_f64_retain(rnd_dist.sample(&mut rand::thread_rng())).unwrap().round_dp(2));
    if order_size + PrimaryAsset::from(ctx.consts.max_order_std_dev_usdc) * dec!(2) >= to_change {
        to_change
    }
    else {
        order_size
    }
}


pub fn get_single_order_size(ctx: &Context, to_change: PrimaryAsset) -> PrimaryAsset {
    if ctx.consts.max_order_usdc.is_zero() {
        to_change
    }
    else {
        rnd_order_size(ctx, to_change)
    }
}


pub fn get_single_order_size_sec(ctx: &Context, to_change: SecondaryAsset, price: Price) -> SecondaryAsset {
    ONE_S.max(get_single_order_size(ctx, to_change.to_prim(price)).to_sec(price))
}


///// Amount of asset to sell to enlarge free assets (and reduce margin)
/////
//pub fn calc_additional_sell_for_free(bal: E1Balances, additional_free: PrimaryAsset, price: Price) -> PrimaryAsset {
//    //
//    // NOTE: this is for dYdX only
//    //
//    // See formulas here:
//    // https://docs.dydx.exchange/#margin-calculation
//    // And constants here (on "Details" tab):
//    // https://trade.dydx.exchange/trade/ATOM-USD
//    const INITIAL_MARGIN_FRACTION : Value = dec!(0.1);
//    let current_margin = bal.total - bal.free;
//    let delta_sec = (-bal.operational_coins) 
//                  - (current_margin - *additional_free) / (price * INITIAL_MARGIN_FRACTION);
//    let delta = sec_to_prim(delta_sec.into(), price);
//    return delta;
//}


